
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#define SDL_MAIN_HANDLED /*To fix SDL's "undefined reference to WinMain"       \
                            issue*/
#include "demos/lv_demos.h"
#include "examples/lv_examples.h"

#include "config.h"

#include <lvgl.h>

#include <lua.h>

#include <lauxlib.h>
#include <lualib.h>

#include <luavgl.h>
#include "extension.h"

#include "hw/dji_display.h"
#include "hw/dji_services.h"
#include "hal/evdev.h"

#include "debug_server/debug_server.h"
#include "utils/screenshot.h"

typedef struct {
  lua_State *L;
  lv_obj_t *root;
} lua_context_t;

typedef struct {
  lv_obj_t *root;
  make_font_cb make_font;
  delete_font_cb delete_font;
} luavgl_args_t;


static dji_display_state_t *dji_display;
static void *fb0_addr;
static void *fb1_addr;
static bool whichfb = 0;
pthread_mutex_t fb_switch_lock;
static screenshot_ctx ss_ctx;

static lv_indev_t * keypad_indev;

/*static lv_color_t buf1_1[BUFSIZE];
static lv_color_t buf1_2[BUFSIZE];*/

void dji_set_px_cb(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)
{
   buf += (y * SCREEN_WIDTH + x)*BYTES_PER_PIXEL;
   lv_color_t *pixel = (lv_color_t *)buf;
   *pixel = color;
   buf[3] = ~opa;
}

void dji_display_flush(lv_disp_drv_t * drv, const lv_area_t * area, lv_color_t * color_p) {
  //printf("%p - %p - %p\n", fb0_addr, fb1_addr, (void*)color_p);
  //printf("x1 - %d \t x2 \t - %d \t y1 - %d \t y2 %d\n", area->x1, area->x2, area->y1, area->y2);
  //printf("w - %d \t h - %d\n", area->x2 - area->x1, area->y2 - area->y1);
  pthread_mutex_lock(&fb_switch_lock);
  void* fb = (whichfb ? fb0_addr : fb1_addr);
  pthread_mutex_unlock(&fb_switch_lock);

  if(lv_disp_flush_is_last(drv)) {
    dji_display_push_frame(dji_display, whichfb);
    whichfb = !whichfb;
  }

  lv_disp_flush_ready(drv);
}

/**
 * Initialize the Hardware Abstraction Layer (HAL) for the LVGL graphics
 * library
 */
static void hal_init(void (*evdev_event_cb)(lv_indev_data_t* data))
{
  dji_display = dji_display_state_alloc(dji_goggles_are_v2());
  dji_display_open_framebuffer(dji_display, PLANE_ID);

  /*Create a display buffer*/

  static lv_disp_draw_buf_t disp_buf1;
  fb0_addr = dji_display_get_fb_address(dji_display, 0);
  fb1_addr = dji_display_get_fb_address(dji_display, 1);
  memset(fb0_addr, 0x000000FF, SCREEN_WIDTH * SCREEN_HEIGHT * BYTES_PER_PIXEL);
  memset(fb1_addr, 0x000000FF, SCREEN_WIDTH * SCREEN_HEIGHT * BYTES_PER_PIXEL);
  lv_disp_draw_buf_init(&disp_buf1, fb0_addr, fb1_addr, SCREEN_WIDTH * SCREEN_HEIGHT * BYTES_PER_PIXEL);

  /*Create a display*/
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv); /*Basic initialization*/
  disp_drv.draw_buf = &disp_buf1;
  disp_drv.flush_cb = dji_display_flush;
  disp_drv.hor_res = SCREEN_WIDTH;
  disp_drv.ver_res = SCREEN_HEIGHT;
  disp_drv.set_px_cb = dji_set_px_cb;
  disp_drv.full_refresh = 1;

  lv_disp_t *disp = lv_disp_drv_register(&disp_drv);

  lv_theme_t *th = lv_theme_default_init(
      disp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),
      LV_THEME_DEFAULT_DARK, LV_FONT_DEFAULT);
  lv_disp_set_theme(disp, th);



  evdev_init(evdev_event_cb);
  lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_KEYPAD;
  indev_drv.read_cb = evdev_read;
  keypad_indev = lv_indev_drv_register(&indev_drv);
  
  
  lv_group_t *g = lv_group_create();
  lv_group_set_default(g);
  lv_indev_set_group(keypad_indev, g);
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char *pname, const char *msg)
{
  printf("%s: %s\n", pname ? pname : " ", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State *L, int status)
{
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message("luactx", msg);
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State *L)
{
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {                         /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)      /* that produces a string? */
      return 1;                              /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                            luaL_typename(L, 1));
  }

  /* append a standard traceback */
  luaL_traceback(L, L, msg, 1);

  msg = lua_tostring(L, -1);
  lua_pop(L, 1);

  lv_obj_t *root = NULL;
  luavgl_ctx_t *ctx = luavgl_context(L);
  root = ctx->root ? ctx->root : lv_scr_act();
  lv_obj_t *label = lv_label_create(root);
  lv_label_set_text(label, msg);
  lv_label_set_long_mode(label, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(label, LV_FONT_DEFAULT, 0);
  lv_obj_set_width(label, LV_PCT(80));
  lv_obj_center(label);

  printf("trace back: \n%s\n", msg);
  return 0; /* return no trace, since we already processed it. */
}

static int lua_panic(lua_State *L)
{
  printf("LUA panic:\n%s\n", lua_tostring(L, -1));
  return 0; /* return to Lua to abort */
}

/*
** protected main entry
*/
static int pmain(lua_State *L)
{
  int status;
  const char *script = lua_tostring(L, 1);

  luavgl_args_t *args = lua_touserdata(L, 2);
  if (args == NULL || args->root == NULL) {
    printf("Null root object.\n");
    return 0;
  }

  luavgl_set_root(L, args->root);
  luavgl_set_font_extension(L, args->make_font, args->delete_font);

  /**
   * Set global variable SCRIPT_PATH, to make image src path easier.
   */
  char *path = strdup(script);
  if (path == NULL) {
    printf("no memory.\n");
    return 0;
  }

  int i = strlen(path);
  for (; i; i--) {
    if (path[i] == '/') {
      path[i + 1] = '\0';
      break;
    }
  }

  printf("script path: %s\n", path);
  lua_pushstring(L, path);
  lua_setglobal(L, "SCRIPT_PATH");
  luaL_openlibs(L);

  lua_getglobal(L, "package");
  lua_getfield(L, -1, "path");

  const char *pkg_path = lua_tostring(L, -1);
  char *new_path = malloc(strlen(pkg_path) + strlen(script) + 2);
  strcpy(new_path, pkg_path);
  strcat(new_path, ";"), strcat(new_path, path), strcat(new_path, "?.lua");
  lua_pop(L, 1);
  lua_pushstring(L, new_path);
  lua_setfield(L, -2, "path");
  lua_pop(L, 1);
  free(path);
  free(new_path);

  lua_atpanic(L, &lua_panic);

  luaL_requiref(L, "lvgl", luaopen_lvgl, 1);
  lua_pop(L, 1);
  luavgl_extension_init(L);

  lua_pushcfunction(L, msghandler); /* push message handler */
  int base = lua_gettop(L);
  status = luaL_loadfile(L, script);
  if (status != LUA_OK) {
    lua_pushfstring(L, "failed to load: %s\n", script);
    /* manually show the error to screen. */
    lua_insert(L, 1);
    msghandler(L);
    return 0;
  }

  status = lua_pcall(L, 0, 0, base);
  lua_remove(L, base); /* remove message handler from the stack */
  report(L, status);
  lua_pushboolean(L, 1); /* signal no errors */
  return 1;
}

lua_context_t *lua_load_script(const char *script, luavgl_args_t *args)
{
  int ret, status;
  /* create the thread to run script. */
  if (script == NULL) {
    printf("args error.\n");
    return NULL;
  }

  printf("run script: %s\n", script);
  lua_State *L = luaL_newstate(); /* create state */
  if (L == NULL) {
    printf("no mem for lua state.\n");
    return NULL;
  }

  lua_pushcfunction(L, &pmain); /* to call 'pmain' in protected mode */
  lua_pushstring(L, script);
  lua_pushlightuserdata(L, args);
  status = lua_pcall(L, 2, 1, 0); /* do the call */
  ret = lua_toboolean(L, -1);
  report(L, status);
  if (!ret || status != LUA_OK) {
    /* This should never happen */
    printf("pcall failed.\n");
    lua_close(L);
    return NULL;
  }

  /* script may fail, but we continue until page destoried. */
  lua_context_t *luactx = calloc(sizeof(*luactx), 1);
  if (luactx == NULL) {
    printf("no memory.\n");
    goto lua_exit;
  }

  luactx->L = L;
  luactx->root = args->root;
  return luactx;

lua_exit:
  lua_close(L);

  return NULL;
}

int lua_terminate(lua_context_t *luactx)
{
  lua_State *L = luactx->L;

  lua_close(L);
  free(luactx);
  return 0;
}

static lua_context_t *lua_ctx;
static luavgl_args_t args;

static void reload()
{
  if (lua_ctx != NULL) {
    lua_terminate(lua_ctx);
  }
  //todo old group should probably be cleaned instead?
  //if we don't init a new one here all input is lost
  lv_group_t *g = lv_group_create();
  lv_group_set_default(g);
  lv_indev_set_group(keypad_indev, g);
  
  lua_ctx = lua_load_script(LUA_START_PATH, &args);
}

static void key_global(lv_indev_data_t* event)
{
    //printf("event %d key %d\n", event->state, event->key);
    switch (event->state) {
    /*case LV_EVENT_CLICKED: // FALL THRU
    case LV_EVENT_LONG_PRESSED_REPEAT:
        audio_play (sound_sinus2000hz_100ms);
        break;
    */
    case LV_INDEV_STATE_REL:
      printf("key released: %d\n", event->key);
      if(event->key == 200) {
        //take a screenshot
        if(!access("/storage/sdcard0/", R_OK )) {
          char path[255];
          time_t now = time(NULL);
          struct tm *t = localtime(&now);
          strftime(path, sizeof(path)-1, "/storage/sdcard0/screenshot %d %m %Y %H:%M:%S.png", t);
          takeScreenshot(&ss_ctx, path);
          printf("took a screenshot to: %s\n", path);
        }
      }
      else if(event->key == LV_KEY_ESC) {
        reload();
      }
      break;
    }
}

int main(int argc, char **argv)
{
  (void)argc; /*Unused*/
  (void)argv; /*Unused*/
  if (pthread_mutex_init(&fb_switch_lock, NULL) != 0) {
    printf("\n mutex init has failed\n");
    return 1;
  }
  //create debug server thread

  ss_ctx.whichfb = &whichfb;
  ss_ctx.fb0 = &fb0_addr;
  ss_ctx.fb1 = &fb1_addr;
  ss_ctx.fb_switch_lock = &fb_switch_lock;
  pthread_t debugThreadHandle;
  pthread_create(&debugThreadHandle, NULL, &acceptConnectionsThread, &ss_ctx);

  //nuke glasses
  dji_stop_goggles(dji_goggles_are_v2());
  usleep(1000000);
  /*Initialize LVGL*/
  lv_init();

  /*Initialize the HAL (display, input devices, tick) for LVGL*/
  hal_init(key_global);

  args.root = lv_scr_act();

  lua_ctx = lua_load_script(LUA_START_PATH, &args);

  while (1) {
    /* Periodically call the lv_task handler.
     * It could be done in a timer interrupt or an OS task too.*/
    lv_timer_handler();
    usleep(5 * 1000);
  }

  dji_display_close_framebuffer(dji_display);
  dji_display_state_free(dji_display);

  return 0;
}
